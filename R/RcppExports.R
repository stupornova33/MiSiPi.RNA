# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' mergePileups
#'
#' This function takes in vectors of start and end positions and pileups positions and their counts
#' It returns a dataframe with only the positions from start and the related counts as found in pileups_count
#'
#' @param start A vector of ints
#' @param end A vector of ints
#' @param pileups_pos A vector of ints
#' @param pileups_count A vector of ints
#' @return A data.frame consisting of positions and the counts associated with those positions
#' @export
mergePileups <- function(start, end, pileups_pos, pileups_count) {
    .Call(`_MiSiPi_RNA_mergePileups`, start, end, pileups_pos, pileups_count)
}

#' get_nearby
#'
#' This function takes in vectors of start and end positions from 2 sets of reads
#' It also takes in an integer that sets the maximum distance apart the reads should be and an integer that tracks the size of the input vectors
#' It returns a data.frame of reads that are nearby - determined by max_dist - but not overlapping
#'
#' @param f_start A vector of ints
#' @param f_end A vector of ints
#' @param r_start A vector of ints
#' @param r_end A vector of ints
#' @param max_dist An integer
#' @param dfsize An integer
#' @return A data.frame of nearby reads
#' @export
get_nearby <- function(f_start, f_end, r_start, r_end, max_dist, dfsize) {
    .Call(`_MiSiPi_RNA_get_nearby`, f_start, f_end, r_start, r_end, max_dist, dfsize)
}

#' getFastas
#'
#' This function takes in a fasta sequence as a string, an int vector of start positions, an int vector of stop positions,
#' and an int to track the size of the input vectors.
#' It returns a data.frame containing each input start and stop positions along with the fasta sequence associated with those positions
#'
#' @param input_str A vector of ints
#' @param start A vector of ints
#' @param stop A vector of ints
#' @param size An integer
#' @return A data.frame consisting of start and stop positions along with their fasta sequence
#' @export
getFastas <- function(input_str, start, stop, size) {
    .Call(`_MiSiPi_RNA_getFastas`, input_str, start, stop, size)
}

#' convertU
#'
#' This function takes in input_str, a vector of strings of nucleotides and converts all 'T's found to 'U's
#' It also takes in an integer called size to track the size of the number of strings in the vector
#' It returns the the vector of converted strings
#'
#' @param input_str A vector of strings
#' @param size An integer
#' @return A vector of strings containing the converted sequences
#' @export
convertU <- function(input_str, size) {
    .Call(`_MiSiPi_RNA_convertU`, input_str, size)
}

#' getPileups
#'
#' This function takes in a fasta sequence as a string, an int vector of start positions, an int vector of stop positions,
#' and an int to track the size of the input vectors.
#' It returns a data.frame containing each input start and stop positions along with the fasta sequence associated with those positions
#'
#' @param input_str A vector of ints
#' @param start A vector of ints
#' @param stop A vector of ints
#' @param size An integer
#' @return A data.frame consisting of start and stop positions along with their fasta sequence
#' @export
getPileups <- function(dtpos, dtcount, start_r1, end_r1, start_r2, end_r2) {
    .Call(`_MiSiPi_RNA_getPileups`, dtpos, dtcount, start_r1, end_r1, start_r2, end_r2)
}

#' vectorsToMap
#'
#' This function takes takes in references to vectors of keys and values
#' These keys and values are turned into pairs in a std::map and returned
#' This function assumes the vectors are of the same size.
#' This is only intended to be called from getPileupsMap
#'
#' @param k A referenced vector of integers representing keys
#' @param v A referenced vector of integers representing values
#' @return A std::map of int pairs
#' @export
vectorsToMap <- function(k, v) {
    .Call(`_MiSiPi_RNA_vectorsToMap`, k, v)
}

#' getPileupsMap
#'
#' This function takes in 2 vectors of calculated pileups and their positions.
#' It also takes in vectors representing start and end positions of read group 1 and 2 with a vector tracking their duplicates
#' It converts the pileups vectors into a std::map and calculates the average pileups in a particular read range and returns it in a data.frame
#'
#' @param dtpos A vector of ints representing positions
#' @param dtcount A vector of ints representing the pileups at each dtpos position
#' @param start_r1 A vector of start positions from read group 1
#' @param end_r1 A vector of end positions from read group 2
#' @param start_r2 A vector of start positions from read group 2
#' @param end_r2 A vector of end positions from read group 2
#' @param count A vector of ints representing the number of duplicates each start_r1, end_r1, start_r2, end_r2 had prior to grouping 
#' @return A data.frame consisting of the average pileups in read 1 range and in read 2 range
#' @export
getPileupsMap <- function(dtpos, dtcount, start_r1, end_r1, start_r2, end_r2, count) {
    .Call(`_MiSiPi_RNA_getPileupsMap`, dtpos, dtcount, start_r1, end_r1, start_r2, end_r2, count)
}

#' group_helix_res
#'
#' This function takes in two vectors of paired positions. It iterates through each and tests to see if a the
#' positions have changed by more than 4 nt in order to track potential hairpin loops.
#' It returns a data.frame consisting of x start and stop positions along with their respective y start and stop positions
#'
#' @param x A vector of ints
#' @param y A vector of ints
#' @return A data.frame consisting of start and stop positions for both x and y
#' @export
group_helix_res <- function(x, y) {
    .Call(`_MiSiPi_RNA_group_helix_res`, x, y)
}

#' calc_overhangs
#'
#' This function takes in vectors of start and stop positions for read groups 1 and 2
#' It then shifts the positions and checks to see which sets have proper and improper overhangs
#' 
#' @param r1_start A vector of ints
#' @param r1_end A vector of ints
#' @param r2_start A vector of ints
#' @param r2_end A vector of ints
#' @return A data.frame representing the number of proper and improper overhangs calculated at each shift position
#' @export
calc_overhangs <- function(r1_start, r1_end, r2_start, r2_width) {
    .Call(`_MiSiPi_RNA_calc_overhangs`, r1_start, r1_end, r2_start, r2_width)
}

#' calc_expand_overhangs
#'
#' This function takes in vectors of start and stop positions for read groups 1 and 2
#' It then shifts the positions and checks to see which sets have proper and improper overhangs
#' Over a larger distance of shifts compared to calc_overhangs
#' 
#' @param r1_start A vector of ints
#' @param r1_end A vector of ints
#' @param r2_start A vector of ints
#' @param r2_end A vector of ints
#' @return A data.frame representing the number of proper and improper overhangs calculated at each shift position
#' @export
calc_expand_overhangs <- function(r1_start, r1_end, r2_start, r2_width) {
    .Call(`_MiSiPi_RNA_calc_expand_overhangs`, r1_start, r1_end, r2_start, r2_width)
}

#' proper_overlap
#'
#' This function takes in two integers representing widths and returns a proper overlap
#' 
#' @param widthx An Integer
#' @param widthy An Integer
#' @return proper_overlap An integer representing what the proper overlap should be for these positions
#' @export
proper_overlap <- function(widthx, widthy) {
    .Call(`_MiSiPi_RNA_proper_overlap`, widthx, widthy)
}

#' overlap_counts
#'
#' This function takes in vectors of start positions from read group 1 and end positions from read group 2
#' It also takes in an overlap amount integer
#' The function counts the number of overlaps occurring and returns them as an integer
#' 
#' @param f_start A vector of ints
#' @param X_SIZE An Integer
#' @param r_end A vector of ints
#' @param Y_SIZE An Integer
#' @param overlap An Integer
#' @return count An Integer representing the number of overlaps present
#' @export
overlap_counts <- function(f_start, X_SIZE, r_end, Y_SIZE, overlap) {
    .Call(`_MiSiPi_RNA_overlap_counts`, f_start, X_SIZE, r_end, Y_SIZE, overlap)
}

#' get_si_overlaps
#'
#' This function takes in vectors of start and stop positions for read groups 1 and 2
#' It calculates overlaps for each set of reads and stores them in a matrix based on the read widths
#' 
#' @param fdt_start A vector of ints
#' @param fdt_end A vector of ints
#' @param fwidth An integer
#' @param rdt_start A vector of ints
#' @param rdt_end A vector of ints
#' @param rwidth An integer
#' @return result A matrix representing the overlaps present at each width of reads from 15-32
#' @export
get_si_overlaps <- function(fdt_start, fdt_end, fwidth, rdt_start, rdt_end, rwidth) {
    .Call(`_MiSiPi_RNA_get_si_overlaps`, fdt_start, fdt_end, fwidth, rdt_start, rdt_end, rwidth)
}

#' get_phased_dist
#'
#' This function takes in vectors of start and stop positions for read groups 1 and 2
#' It calculates the distance between the end of one group and start of another and returns
#' The results in a data.frame
#' 
#' @param startX A vector of ints
#' @param endX A vector of ints
#' @param startY A vector of ints
#' @param endY A vector of ints
#' @param dfsize An integer
#' @return df A data.frame containing the start positions of both reads, their widths, and the distance
#' @export
get_phased_dist <- function(startX, endX, startY, endY, dfsize) {
    .Call(`_MiSiPi_RNA_get_phased_dist`, startX, endX, startY, endY, dfsize)
}

#' make_count_table
#' 
#' This functions calculates the counts of each overlap to be used for z score
#' 
#' @param fdt_start A vector of ints
#' @param fdt_end A vector of ints
#' @param fwidth An integer
#' @param rdt_start A vector of ints
#' @param rdt_end A vector of ints
#' @param rwidth An integer
#' @return df A data.frame containing the counts of each overlap to be used for a z score
#' @export
make_count_table <- function(fdt_start, fdt_end, fwidth, rdt_start, rdt_end, rwidth) {
    .Call(`_MiSiPi_RNA_make_count_table`, fdt_start, fdt_end, fwidth, rdt_start, rdt_end, rwidth)
}

#' get_pi_overlaps
#'
#' This function calculates the overlaps present at each width of reads from 15-32
#' 
#' @param fdt_start A vector of ints
#' @param fdt_end A vector of ints
#' @param fwidth An integer
#' @param rdt_start A vector of ints
#' @param rdt_end A vector of ints
#' @param rwidth An integer
#' @return result A matrix representing the overlaps present at each width of reads from 15-32
#' @export
get_pi_overlaps <- function(fdt_start, fdt_end, fwidth, rdt_end, rdt_start, rwidth) {
    .Call(`_MiSiPi_RNA_get_pi_overlaps`, fdt_start, fdt_end, fwidth, rdt_end, rdt_start, rwidth)
}

#' getLoopPileupsCPP
#'
#' This function returns a data.frame containing the start and stop positions of read 1, read 2, and a loop
#' If the number of pileups in a loop divided by the total number of pileups is less that 0.05
#' 
#' @param r1Start A vector of ints
#' @param r1Stop A vector of ints
#' @param lStart A vector of ints
#' @param lStop A vector of ints
#' @param r2Start A vector of ints
#' @param r2Stop A vector of ints
#' @param dt_col_1 A vector of ints
#' @param dt_col_2 A vector of ints
#' @param int total_count An integer
#' @return df A data.frame
#' @export
getLoopPileupsCPP <- function(r1Start, r1Stop, lStart, lStop, r2Start, r2Stop, dt_col_1, dt_col_2, total_count) {
    .Call(`_MiSiPi_RNA_getLoopPileupsCPP`, r1Start, r1Stop, lStart, lStop, r2Start, r2Stop, dt_col_1, dt_col_2, total_count)
}

